// Auto-generated by avdl-compiler v1.3.23 (https://github.com/keybase/node-avdl-compiler)
//   Input file: avdl/emom1/ae.avdl

package emom1

import (
	"github.com/keybase/go-framed-msgpack-rpc/rpc"
	context "golang.org/x/net/context"
)

type AuthEnc struct {
	N int64  `codec:"n" json:"n"`
	E []byte `codec:"e" json:"e"`
}

func (o AuthEnc) DeepCopy() AuthEnc {
	return AuthEnc{
		N: o.N,
		E: (func(x []byte) []byte {
			if x == nil {
				return nil
			}
			return append([]byte{}, x...)
		})(o.E),
	}
}

type KID []byte

func (o KID) DeepCopy() KID {
	return (func(x []byte) []byte {
		if x == nil {
			return nil
		}
		return append([]byte{}, x...)
	})(o)
}

type Hash []byte

func (o Hash) DeepCopy() Hash {
	return (func(x []byte) []byte {
		if x == nil {
			return nil
		}
		return append([]byte{}, x...)
	})(o)
}

type UID []byte

func (o UID) DeepCopy() UID {
	return (func(x []byte) []byte {
		if x == nil {
			return nil
		}
		return append([]byte{}, x...)
	})(o)
}

type Time int64

func (o Time) DeepCopy() Time {
	return o
}

type Handshake struct {
	V int `codec:"v" json:"v"`
	S int `codec:"s" json:"s"`
	K KID `codec:"k" json:"k"`
}

func (o Handshake) DeepCopy() Handshake {
	return Handshake{
		V: o.V,
		S: o.S,
		K: o.K.DeepCopy(),
	}
}

type MsgpackHeader struct {
	T int `codec:"t" json:"t"`
	S int `codec:"s" json:"s"`
}

func (o MsgpackHeader) DeepCopy() MsgpackHeader {
	return MsgpackHeader{
		T: o.T,
		S: o.S,
	}
}

type RequestPlaintext struct {
	H MsgpackHeader    `codec:"h" json:"h"`
	N string           `codec:"n" json:"n"`
	A []byte           `codec:"a" json:"a"`
	F *SignedAuthToken `codec:"f,omitempty" json:"f,omitempty"`
}

func (o RequestPlaintext) DeepCopy() RequestPlaintext {
	return RequestPlaintext{
		H: o.H.DeepCopy(),
		N: o.N,
		A: (func(x []byte) []byte {
			if x == nil {
				return nil
			}
			return append([]byte{}, x...)
		})(o.A),
		F: (func(x *SignedAuthToken) *SignedAuthToken {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.F),
	}
}

type ResponsePlaintext struct {
	H MsgpackHeader `codec:"h" json:"h"`
	R []byte        `codec:"r" json:"r"`
}

func (o ResponsePlaintext) DeepCopy() ResponsePlaintext {
	return ResponsePlaintext{
		H: o.H.DeepCopy(),
		R: (func(x []byte) []byte {
			if x == nil {
				return nil
			}
			return append([]byte{}, x...)
		})(o.R),
	}
}

type AuthToken struct {
	U UID  `codec:"u" json:"u"`
	E Time `codec:"e" json:"e"`
	K KID  `codec:"k" json:"k"`
}

func (o AuthToken) DeepCopy() AuthToken {
	return AuthToken{
		U: o.U.DeepCopy(),
		E: o.E.DeepCopy(),
		K: o.K.DeepCopy(),
	}
}

type SignedAuthToken struct {
	T AuthToken `codec:"t" json:"t"`
	D KID       `codec:"d" json:"d"`
	S []byte    `codec:"s" json:"s"`
}

func (o SignedAuthToken) DeepCopy() SignedAuthToken {
	return SignedAuthToken{
		T: o.T.DeepCopy(),
		D: o.D.DeepCopy(),
		S: (func(x []byte) []byte {
			if x == nil {
				return nil
			}
			return append([]byte{}, x...)
		})(o.S),
	}
}

type Arg struct {
	A AuthEnc    `codec:"a" json:"a"`
	H *Handshake `codec:"h,omitempty" json:"h,omitempty"`
	s rpc.SeqNumber
}

func (o Arg) DeepCopy() Arg {
	return Arg{
		A: o.A.DeepCopy(),
		H: (func(x *Handshake) *Handshake {
			if x == nil {
				return nil
			}
			tmp := (*x).DeepCopy()
			return &tmp
		})(o.H),
		s: o.s,
	}
}

type Res struct {
	A AuthEnc `codec:"a" json:"a"`
	s rpc.SeqNumber
}

func (o Res) DeepCopy() Res {
	return Res{
		A: o.A.DeepCopy(),
		s: o.s,
	}
}

type CArg struct {
	A Arg `codec:"a" json:"a"`
}

type NArg struct {
	A Arg `codec:"a" json:"a"`
}

type AeInterface interface {
	C(context.Context, Arg) (Res, error)
	N(context.Context, Arg) error
}

func AeProtocol(i AeInterface) rpc.Protocol {
	return rpc.Protocol{
		Name: "emom.1.ae",
		Methods: map[string]rpc.ServeHandlerDescription{
			"c": {
				MakeArg: func() interface{} {
					ret := make([]CArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]CArg)
					if !ok {
						err = rpc.NewTypeError((*[]CArg)(nil), args)
						return
					}
					ret, err = i.C(ctx, (*typedArgs)[0].A)
					return
				},
				MethodType: rpc.MethodCall,
			},
			"n": {
				MakeArg: func() interface{} {
					ret := make([]NArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]NArg)
					if !ok {
						err = rpc.NewTypeError((*[]NArg)(nil), args)
						return
					}
					err = i.N(ctx, (*typedArgs)[0].A)
					return
				},
				MethodType: rpc.MethodNotify,
			},
		},
	}
}

type AeClient struct {
	Cli rpc.GenericClient
}

func (c AeClient) C(ctx context.Context, a Arg) (res Res, err error) {
	__arg := CArg{A: a}
	err = c.Cli.Call(ctx, "emom.1.ae.c", []interface{}{__arg}, &res)
	return
}

func (c AeClient) N(ctx context.Context, a Arg) (err error) {
	__arg := NArg{A: a}
	err = c.Cli.Notify(ctx, "emom.1.ae.n", []interface{}{__arg})
	return
}
